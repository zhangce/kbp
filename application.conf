deepdive {

  db.default {
    driver: "org.postgresql.Driver"
    url: "jdbc:postgresql://"${PGHOST}":"${PGPORT}"/"${DBNAME}
    user: ${PGUSER}
    password: ${PGPASSWORD}
  }

  calibration.holdout_fraction: 0.5

  ###
  ### VARIABLES
  ###

  schema.variables {
    relation_mentions.is_correct: Boolean
  }

  pipeline.run: "debug_mention_ext"
  pipeline.pipelines.debug_mention_ext: ["ext_relation_mention_feature_deppath_debug"]

  ###
  ### EXTRACTORS
  ###

  extraction.extractors {

    # Clean output tables of all extractors.
    ext_cleanup {
      sql: """
        DELETE FROM relation_mentions;
        DELETE FROM relation_mention_features;
        DELETE FROM mentions;
      """
      style: "sql_extractor"
    }

    #
    # Entity mentions
    #

    # Extract entity mentions from the sentences.
    ext_mention {
      input : """
        SELECT doc_id,
               sentence_id,
               my_array_to_string(words, '~^~', 'NULL') AS words,
               my_array_to_string(ner, '~^~', 'NULL') AS ner,
               my_array_to_string(character_offset_begin, '~^~', 'NULL') AS character_offset_begin,
               my_array_to_string(character_offset_end, '~^~', 'NULL') AS character_offset_end
        FROM sentence
      """
      output_relation: "mentions"
      udf: ${APP_HOME}"/udf/ext_mention.py"
      style: "tsv_extractor"
      dependencies : ["ext_cleanup"]
    }

    # # Useful for debugging the entity mention extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <entity_mention_extractor> to see its output.
    # ext_mention_debug {
    #   input : """
    #     SELECT doc_id,
    #            sentence_id,
    #            my_array_to_string(words, '~^~', 'NULL') AS words,
    #            my_array_to_string(ner, '~^~', 'NULL') AS ner,
    #            my_array_to_string(character_offset_begin, '~^~', 'NULL') AS character_offset_begin,
    #            my_array_to_string(character_offset_end, '~^~', 'NULL') AS character_offset_end
    #     FROM sentence LIMIT 100
    #   """
    #   output_relation: "mentions"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_mention_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies : ["ext_cleanup"]
    # }

    #
    # Relation mention feature extractors.
    #
    # Extract features from relation mentions; relation mentions are pairs of entity mentions that
    # appear in the same sentence  The input query creates several lists of mention attributes
    # (mention_id, types, etc.) for each sentence, so the input to the extractor is a list of all
    # the mentions in a given sentence. The extractor then does an n^2 loop over these mentions to
    # get all potential mention pairs.    

    # Extract the feature which is the word sequence between the 2 mentions.
    ext_relation_mention_feature_wordseq {
      input: """
        SELECT s.doc_id AS doc_id,
               s.sentence_id AS sentence_id,
               array_to_string(max(s.lemma), '~^~') AS lemma,
               array_to_string(max(s.words), '~^~') AS words,
               array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
               array_to_string(array_accum(m.word), '~^~') AS mention_words,
               array_to_string(array_accum(m.type), '~^~') AS types,
               array_to_string(array_accum(m.start_pos), '~^~') AS starts,
               array_to_string(array_accum(m.end_pos), '~^~') AS ends
        FROM sentence s,
             mentions m
        WHERE s.doc_id = m.doc_id AND
              s.sentence_id = m.sentence_id
        GROUP BY s.doc_id,
                 s.sentence_id
        """
      output_relation: "relation_mention_features"
      udf: ${APP_HOME}"/udf/ext_relation_mention_features_wordseq.py"
      style: "tsv_extractor"
      dependencies: ["ext_cleanup", "ext_mention"]
    }

    # # Useful for debugging the relation mention word sequence feature extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <relation_mention_wordseq_extractor> to see its output.
    # ext_relation_mention_feature_wordseq_debug {
    #   input: """
    #     SELECT s.doc_id AS doc_id,
    #            s.sentence_id AS sentence_id,
    #            array_to_string(max(s.lemma), '~^~') AS lemma,
    #            array_to_string(max(s.words), '~^~') AS words,
    #            array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
    #            array_to_string(array_accum(m.word), '~^~') AS mention_words,
    #            array_to_string(array_accum(m.type), '~^~') AS types,
    #            array_to_string(array_accum(m.start_pos), '~^~') AS starts,
    #            array_to_string(array_accum(m.end_pos), '~^~') AS ends
    #     FROM sentence s,
    #          mentions m
    #     WHERE s.doc_id = m.doc_id AND
    #           s.sentence_id = m.sentence_id
    #     GROUP BY s.doc_id,
    #              s.sentence_id
    #     """
    #   output_relation: "relation_mention_features"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_relation_mention_wordseq_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies: ["ext_cleanup", "ext_mention"]
    # }

    # Extract the dependency path between the 2 mentions.
    ext_relation_mention_feature_deppath {
      input: """
        SELECT s.doc_id AS doc_id,
               s.sentence_id AS sentence_id,
               array_to_string(max(s.lemma), '~^~') AS lemma,
               replace(array_to_string(max(s.dep_graph), '~^~'), E'\t', ' ') AS dep_graph,
               array_to_string(max(s.words), '~^~') AS words,
               array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
               array_to_string(array_accum(m.word), '~^~') AS mention_words,
               array_to_string(array_accum(m.type), '~^~') AS types,
               array_to_string(array_accum(m.start_pos), '~^~') AS starts,
               array_to_string(array_accum(m.end_pos), '~^~') AS ends
        FROM sentence s,
             mentions m
        WHERE s.doc_id = m.doc_id AND
              s.sentence_id = m.sentence_id
        GROUP BY s.doc_id,
                 s.sentence_id
        """
      output_relation: "relation_mention_features"
      udf: ${APP_HOME}"/udf/ext_relation_mention_features_deppath.py"
      style: "tsv_extractor"
      dependencies: ["ext_cleanup", "ext_mention"]
    }

    # # Useful for debugging the relation mention dependency path feature extractor.
    # # Produes a TSV file with the input query materialized; to debug the extractor simply run
    # # cat <file> | python <relation_mention_deppath_extractor> to see its output.
    # ext_relation_mention_feature_deppath_debug {
    #   input: """
    #     SELECT s.doc_id AS doc_id,
    #            s.sentence_id AS sentence_id,
    #            array_to_string(max(s.lemma), '~^~') AS lemma,
    #            replace(array_to_string(max(s.dep_graph), '~^~'), E'\t', ' ') AS dep_graph,
    #            array_to_string(max(s.words), '~^~') AS words,
    #            array_to_string(array_accum(m.mention_id), '~^~') AS mention_ids,
    #            array_to_string(array_accum(m.word), '~^~') AS mention_words,
    #            array_to_string(array_accum(m.type), '~^~') AS types,
    #            array_to_string(array_accum(m.start_pos), '~^~') AS starts,
    #            array_to_string(array_accum(m.end_pos), '~^~') AS ends
    #     FROM sentence s,
    #          mentions m
    #     WHERE s.doc_id = m.doc_id AND
    #           s.sentence_id = m.sentence_id
    #     GROUP BY s.doc_id,
    #              s.sentence_id
    #     """
    #   output_relation: "relation_mention_features"
    #   udf: ${APP_HOME}"/udf/util/dummy_extractor.py "${APP_HOME}"/udf/sample_data/ext_relation_mention_deppath_sample_data.tsv"
    #   style: "tsv_extractor"
    #   dependencies: ["ext_cleanup", "ext_mention"]
    # }

    #
    # Coreference
    #

    # Extract candidate coreferent entity mentions; the candidate set is the set of mention
    # pairs that appear in the same document, both have the PERSON type, and one begins
    # with the text of the other.
    ext_coref_candidate {
      sql: """
        DROP TABLE IF EXISTS coref_candidates;

        CREATE TABLE coref_candidates AS
          SELECT DISTINCT ON (m0.word, m1.word, m0.mention_id)
               m0.doc_id,
               m0.mention_id AS mid1,
               m1.mention_id AS mid2
          FROM mentions m0,
               mentions m1
          WHERE m0.doc_id = m1.doc_id AND
                m0.type = 'PERSON' AND
                m1.type = 'PERSON' AND
                m1.word LIKE m0.word || ' %' AND
                m0.mention_id <> m1.mention_id ;
      """
      style: "sql_extractor"
      dependencies : ["ext_mention"]
    }

    #
    # Entity linking
    #

    # High-precision entity linking feature.
    # Choose pairs of PERSON mentions and entities where the entity and mention strings match
    # exactly and the mention string contains a space.
    ext_el_feature_extstr_person {
      sql: """
        DROP TABLE IF EXISTS el_features_highprec;

        CREATE TABLE el_features_highprec AS
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'es'::TEXT AS feature
          FROM   mentions m,
                 entities e
          WHERE  m.type = 'PERSON' AND
                 e.type = 'people.person' AND
                 m.word like '% %' AND
                 m.word = e.text;
      """
      style: "sql_extractor"
      dependencies : ["ext_mention"]
    }

    # High-precision entity linking feature: exact string match on the freebase alias (PERSON).
    # Choose pairs of PERSON mentions and entities where the mention string contains a space and
    # the freebase alias for the entity is an exact string match for the mention text.
    ext_el_feature_alias_person {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'al'::TEXT AS feature
          FROM   mentions m,
                 entities e,
                 fbalias f
          WHERE  m.type = 'PERSON' AND
                 e.type = 'people.person' AND
                 m.word = f.slot AND
                 e.fid = f.fid AND
                 m.word like '% %';
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on the freebase alias (ORGANIZATION).
    # Choose pairs of ORGANIZATION mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    ext_el_feature_alias_organization {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'al'::TEXT AS feature
          FROM   mentions m,
                 entities e,
                 fbalias f
          WHERE  m.type = 'ORGANIZATION' AND
                 e.type = 'organization.organization' AND
                 m.word = f.slot AND
                 e.fid = f.fid;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on the freebase alias (LOCATION).
    # Choose pairs of LOCATION mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    ext_el_feature_alias_location {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'al'::TEXT AS feature
          FROM   mentions m,
                 entities e,
                 fbalias f
          WHERE  m.type = 'LOCATION' AND
                 e.type = 'location.location' AND
                 m.word = f.slot AND
                 e.fid = f.fid;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on the freebase alias (TITLE).
    # Choose pairs of TITLE mentions and entities where
    # the freebase alias for the entity is an exact string match for the mention text.
    ext_el_feature_alias_title {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'al'::TEXT AS feature
          FROM   mentions m,
                 entities e,
                 fbalias f
          WHERE  m.type = 'TITLE' AND
                 e.type = 'business.job_title' AND
                 m.word = f.slot AND
                 e.fid = f.fid;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on LOCATION.
    # Choose pairs of LOCATION mentions and entities where the text matches exactly.
    ext_el_feature_extstr_location {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'es'::TEXT AS feature
          FROM   mentions m,
                 entities e
          WHERE  m.type = 'LOCATION' AND
                 e.type = 'location.location' AND
                 m.word = e.text;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on ORGANIZATION.
    # Choose pairs of 'ORGANIZATION' mentions and 'organization.organization' entities where the
    # text matches exactly.
    ext_el_feature_extstr_organization {
      sql: """
          INSERT INTO el_features_highprec
            SELECT m.doc_id,
                   m.mention_id,
                   e.fid,
                   'es'::TEXT AS feature
            FROM   mentions m,
                   entities e
            WHERE  m.type = 'ORGANIZATION' AND
                   e.type = 'organization.organization' AND
                   m.word = e.text;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on TITLE.
    # Choose pairs of 'TITLE' mentions and 'business.job_title' entities where the text
    # matches exactly.
    ext_el_feature_extstr_title {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'es'::TEXT AS feature
          FROM   mentions m,
                 entities e
          WHERE  m.type = 'TITLE' AND
                 e.type = 'business.job_title' AND
                 m.word = e.text;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: exact string match on TITLE.
    # Choose pairs of 'TITLE' mentions and 'government.government_office_or_title' entities where
    # the text matches exactly.
    ext_el_feature_extstr_title2 {
      sql: """
        INSERT INTO el_features_highprec
          SELECT m.doc_id,
                 m.mention_id,
                 e.fid,
                 'es'::TEXT AS feature
          FROM   mentions m,
                 entities e
          WHERE  m.type = 'TITLE' AND
                 e.type = 'government.government_office_or_title' AND
                 m.word = e.text;
      """
      dependencies : ["ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    # High-precision entity linking feature: coreferent mentions.
    # Given the entity and mention pair (e1, m1) for which we have high-precision entity linking
    # in the form of exact string match, and mention m2 that is coreferent with m1, choose
    # (e1, m2) to have the coreference entity linking feature.
    ext_el_feature_coref {
      sql: """
        INSERT INTO el_features_highprec
          SELECT c.doc_id,
                 c.mid1,
                 el.fid,
                 'co'::TEXT
          FROM   coref_candidates c,
                 el_features_highprec el
          WHERE  el.feature = 'es' AND
                 c.mid2 = el.mention_id AND
                 c.doc_id = el.doc_id;
      """
      dependencies : ["ext_coref_candidate", "ext_el_feature_extstr_person"]
      style: "sql_extractor"
    }

    #
    # Training data
    #

    # Positive examples for relation mentions. These are taken from the table kb, which
    # contains tuples of the form (entity1, relation, entity2).
    ext_relation_mention_positive {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT r.doc_id,
                          r.mid1,
                          r.mid2,
                          r.word1,
                          r.word2,
                          kb.rel,
                          True
          FROM relation_mention_features r,
               el_features_highprec t1,
               el_features_highprec t2,
               kb
          WHERE r.mid1 = t1.mention_id AND
                r.mid2 = t2.mention_id AND
                t1.fid = kb.eid1 AND
                t2.fid = kb.eid2 AND
                r.doc_id = t1.doc_id AND
                r.doc_id = t2.doc_id;
      """
      dependencies : ["ext_el_feature_coref", "ext_el_feature_extstr_title", 
                      "ext_el_feature_extstr_organization", "ext_el_feature_extstr_location",
                      "ext_el_feature_extstr_person", "ext_coref_candidate", "ext_coref_candidate",
                      "ext_relation_mention_feature", "ext_relation_mention_feature_deppath", 
                      "ext_mention", "ext_el_feature_alias_person",
                      "ext_el_feature_alias_title", "ext_el_feature_alias_location",
                      "ext_el_feature_alias_organization"]
      style: "sql_extractor"
    }

    # Negative examples for relation mentions using a table of incompatible relations. For a given
    # positive example (entity1, relation1, entity2), a negative example would be
    # (entity1, relation2, entity2) where relation2 is incompatible with relation1.
    ext_relation_mention_negative {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT t0.doc_id,
                          t0.mid1,
                          t0.mid2,
                          t0.word1,
                          t0.word2,
                          t1.type2,
                          False
          FROM relation_mentions t0,
               incompatible_relations t1
          WHERE t0.rel = t1.type1 AND
                t0.is_correct = True AND
                t0.rel <> t1.type2;
      """
      dependencies : ["ext_relation_mention_positive"]
      style: "sql_extractor"
    }

    #
    # Relation mentions
    #

    # Populate the relation mention table with non-example tuples; since we already extracted
    # features for relation mentions, simply use that table to get the relation mentions.
    ext_relation_mention {
      sql: """
        INSERT INTO relation_mentions (doc_id, mid1, mid2, word1, word2, rel, is_correct)
          SELECT DISTINCT t1.doc_id,
                          t1.mid1,
                          t1.mid2,
                          t1.word1,
                          t1.word2,
                          t0.rel,
                          NULL::boolean
          FROM relation_types t0,
               relation_mention_features t1
          WHERE t0.type1 = t1.type1 AND
                t0.type2 = t1.type2;
      """
      dependencies : ["ext_relation_mention_positive", "ext_relation_mention_negative"]
      style: "sql_extractor"
    }

  }

  ###
  ### INFERENCE RULES
  ###

  inference.factors: {

    # Learn the expectation for the is_correct column of relation_mentions using the
    # features for a given relation mention. The system will learn a weight for each feature using
    # the positive and negative examples.
    relation_mention_lr {
      input_query: """
        SELECT t0.doc_id AS "distribute.key",
               t0.id AS "relation_mentions.id",
               t0.is_correct AS "relation_mentions.is_correct",
               t0.rel || '_' || t1.feature AS "feature"
        FROM relation_mentions t0,
             relation_mention_features t1
        WHERE t0.doc_id = t1.doc_id AND
              t0.mid1 = t1.mid1 AND
              t0.mid2 = t1.mid2;
      """
      function: "IsTrue(relation_mentions.is_correct)"
      weight: "?(feature)"
    }

  }

}
